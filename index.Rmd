---
title: "Portfolio"
author: "Morris de Haan"
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    storyboard: true
    
    css: style.css
    theme:
      version: 4
      bootswatch: cerulean
---

```{r setup, include=FALSE}
library(flexdashboard)
library(tidyverse)
library(spotifyr)
library(ggplot2)
library(compmus)
library(jsonlite)
library(dplyr)
library(plotly)
library(cowplot)
library(showtext)
library(tm)
library(wordcloud2)
library(patchwork)

# load environment variables
readRenviron(".Renviron")

portfolio_font <- "Times New Roman"
custom_theme <- theme(text=element_text(family=portfolio_font))
```

```{r load corpus, include=FALSE}
#! fetch data

corpus_raw <- get_playlist_audio_features("", "1H9BY5uJqk2CWtPo4Ogi2w")
```

```{r preprocess corpus, include=FALSE}
#! preprocess data

corpus <- corpus_raw %>% select(
  loudness, mode, tempo, valence, key,
  popularity=track.popularity, artists=track.artists, track=track.name
)

# key index --> key name
pretty_keys <- c("C", "C♯|D♭", "D", "D♯|E♭", "E", "F", "F♯|G♭", "G", "G♯|A♭",  "A", "A♯|B♭", "B")
ugly_keys <- c("C", "C#|Db", "D", "D#|Eb", "E", "F", "F#|Gb", "G", "G#|Ab", "A", "A#|Bb", "B")
corpus$key <- unlist(map(corpus$key, function(idx) if (idx == -1) "Unknown" else pretty_keys[idx+1]))

# mode index --> mode name
corpus$mode <- unlist(map(corpus$mode, function(idx) if (idx == 1) "Major" else "Minor"))

# concatenate artist names into single string
corpus$artists <- unlist(map(corpus$artists, function(r) paste(r$name, collapse=", ")))

# TODO: tempo to perceived tempo?
```

```{r fetch lyrics, include=FALSE}
#! load lyrics, delete entries from corpus whose lyrics cannot be fetched

LYRICS_DIR <- "./res"
LYRICS_FILE <- "./res/lyrics.json"
LYRICS_APIKEY <- Sys.getenv("MUSIXMATCH_APIKEY")
LYRICS_URL <- sprintf(paste(
  "https://api.musixmatch.com/ws/1.1/matcher.lyrics.get?",
  "q_track=%s&q_artist=%s&apikey=%s", sep=""),
  "%s", "%s", LYRICS_APIKEY
)

# fetches the lyrics of a track from some artists from Musixmatch
get_lyrics <- function(track, artists) {
  # there may be no spaces in the URL
  track <- gsub(" ", "%20", track)
  artists <- gsub(" ", "%20", artists)
  
  data <- jsonlite::fromJSON(sprintf(LYRICS_URL, track, artists))
  lyrics <- data$message$body$lyrics$lyrics_body
  # remove warning at the end
  lyrics <- gsub(
    "\n...\n\n\\*{7} This Lyrics is NOT for Commercial use \\*{7}.*",
    "", lyrics
  )
  return(lyrics)
}

# load stored lyrics
if (!file.exists(LYRICS_FILE)) {
  lyrics_db <- data.frame(
    track=character(), artists=character(),
    album=character(), lyrics=character()
  )
  
  dir.create(LYRICS_DIR)
} else {
  # fetch all previously cached lyrics
  lyrics_db <- jsonlite::fromJSON(LYRICS_FILE)
}

for (i in 1:nrow(corpus)) {
  row <- corpus[i,]
  
  # check if lyrics are already loaded
  if (!(row$track %in% lyrics_db$track)) {
    # fetch lyrics
    lyrics <- get_lyrics(row$track, row$artists)
    if (length(lyrics) == 0)
      lyrics <- NA
    
    # store lyrics
    lyrics_db <- lyrics_db %>% add_row(
      track=row$track, artists=row$artists,
      lyrics=lyrics
    )
  }
}

# cache lyrics
write(jsonlite::toJSON(lyrics_db, pretty=TRUE), LYRICS_FILE)
```

```{r compute sentiment, include=FALSE}
#! add lyrical sentiment values to corpus, delete tracks from corpus
#!  that have no available lyrics

# compute sentiments
system("python3 lyrics.py")

lyrics_db <- jsonlite::fromJSON(LYRICS_FILE)[c("track", "sentiment")]

corpus <- merge(corpus, lyrics_db, by="track") %>%
  rename(lyrical_sentiment=sentiment) %>%
  drop_na(lyrical_sentiment)
```

### Introduction

How does music relate to the lyrics? It is tempting to think that a song tries to convey some feeling or emotion, and that both the music and lyrics are there to support this message. Let me give you an example. We might expect a song with a slow beat and laid back guitar to talk about laid back topics, maybe a trip to the beach. At the other end of the spectrum, heavy metal would likely concern itself with darker, heavier subjects. However, are these suspicions even true? Let’s put some numbers to the hypothesis that there in fact is a relationship between music and lyrics. In the next sections I’ll take you through a journey where we approach this topic with a statistical mindset, harnessing all the powers that modern technology has to offer along the way.

We'll start out with picking a large body of music and for each track in there, we are going to collect and store the lyrics. It would be way too cumbersome to scrape all the lyrics from the internet myself, but fortunately the [`Musixmatch`](https://www.musixmatch.com/) API
allows querying lyrics from code in a single API call. For an unpaid account only 30% of the lyrics for a queried track is returned, but that will do for our intents and purposes. I assign every set of lyrics a sentimental, or valency, score automatically using the 
[`NLTK`](https://www.nltk.org/) package, which offers natural language processing functionalities. A low score indicates a *sad* feeling, whereas a high score a *happy* feeling. When the lyrics have a numerical score we can start to answer our question: how does music relate to lyrics?

The research question is still a bit broad. We settled on how to analyze lyrics, but not yet on which aspects on music we'll focus.
We are going to keep the research broad, and explore how the lyrics relate to the four main elements of music, that is *melody*, *harmony*, *instrumentation* and *rhythm*. To access and preprocess the music properties the [`Spotify`](https://developer.spotify.com/documentation/web-api) API is used. For each element we will either confirm or refute
any hypotheses that intuitively make a lot of sense, but are not (yet) backed up by data.

Let us dive into it!

### Corpus

The first order of business is choosing the corpus of music. We have chosen a broad research question and the corpus should
reflect this. It must draw inspiration from various genres and contain a large number of songs, only then can we
justify general conclusions. Because the heavy lifting in terms of fetching the data we need is done by the `Musixmatch` and `Spotify` APIs,
this is most certainly possible.

The exhaustive list of albums that are included in this research:

<span style="color:blue">
Elephant, Madvillainy, ..Like Clockwork, Street Worms, Midnights,
HEROES & VILLAINS, St. Elsewhere, The White Album, Plastic Beach,
Demon Days, Thriller, In the Aeroplane Over the Sea, Hawaii: Part ||,
WHEN WE ALL FALL ASLEEP, WHERE DO WE GO?, Dua Lipa, The Money Store, OFFLINE!,
OK Computer and Rumours
</span>

This totals over **280** tracks and **16** hours of listening time.

***

**Playlist**

<iframe src="https://open.spotify.com/embed/playlist/1H9BY5uJqk2CWtPo4Ogi2w?utm_source=generator" width="100%" height="380" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>

### Discovery

```{r discovery}
# TODO: where did the popularity legend go??
ggplotly(
  ggplot(corpus, aes(valence, lyrical_sentiment, col=loudness, size=popularity, text=paste(track, "by", artists))) +
  geom_point() +
  geom_smooth(inherit.aes=FALSE, aes(valence, lyrical_sentiment)) +
  geom_rug(linewidth=0.2) +
  labs(title="Musical vs. Lyrical Valence", x="Musical valence", y="Lyrical Valence", col="Loudness (Decibels)", size="Popularity") +
  custom_theme
)
```

***

The `Spotify` API offers functionalities that range from very high to very low level. Here we will use some the the high level analyses
like valence and energy to learn about the corpus.

When we plot energy, musical and lyrical valence values against each other we find something enormously interesting.
Clearly, even though energy and valence do not seem related, musical and lyrical valence appear highly correlated.

### Melody

```{r melody}
get_audio_analysis <- function(uri) {
  get_tidy_audio_analysis(uri) %>%
    select(segments) %>%
    unnest(segments) %>%
    select(start, duration, pitches)
}

get_chromogram <- function(analysis, title) {
  analysis %>%
    mutate(pitches=map(pitches, compmus_normalize, "euclidean")) %>%
    compmus_gather_chroma() %>%
    ggplot(aes(start + duration*0.5, pitch_class, width=duration, fill=value)) +
    geom_tile() +
    labs(title=title, x="Time (seconds)", y=NULL, fill="Magnitude") +
    # TODO: part of custom theme?
    scale_fill_viridis_c(option="mako", guide="none") +
    theme_minimal() +
    custom_theme
}

# Ball and Biscuit by the white stripes
happy_analysis <- get_audio_analysis("0O2SYh5AZ0y8MAPOVC4Mxz")
# The Illest Villains by Madvillain
sad_analysis <- get_audio_analysis("2Jn0wHQ2lEif2gLRsyfaf2")

happy_entry <- (corpus %>% filter(track == "Ball and Biscuit"))
sad_entry <- (corpus %>% filter(track == "The Illest Villains"))

# TODO: fix background
plot_grid(
  get_chromogram(happy_analysis,
    sprintf("%s chromogram (lyrical valency = %s)", happy_entry$track,
      format(happy_entry$lyrical_sentiment, digits=2)
  )),
  get_chromogram(sad_analysis,
    sprintf("%s chromogram (lyrical valency = %s)", sad_entry$track,
      format(sad_entry$lyrical_sentiment, digits=2)
  )),
  nrow=2
)
```

***

Intuitively, it would appear that melody encodes a lot of the valency information of a song. The melody is usually the most
memorable part and often indicative of the feel of a song. So it makes sense to look at the melody of two tracks, one with low and one
with high lyrical valence. A visualization tool that makes sense to use, is a chromogram. This captures for each moment the notes that
are played, as analyzed using the fourier transform. Let's try this and see if any melody lines become apparent.

Unfortunately, looking at the chromograms, no discernible melody is recognizable. The only thing that sticks out is the droning 'E' in Ball and Biscuit, but this could hardly be called a melody. It appears we need a different tool.

### Melody: What is the happiest key?

```{r per key lyrical valence, message=FALSE}
# TODO: optimize
per_key_valences <- rbind(
  # add average per key
  corpus %>%
    mutate(mode="Either") %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n()),
  corpus %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n()),
  # add average for all keys
  corpus %>%
    mutate(key="Mean\nof all\nkeys", mode="Either") %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n()),
  corpus %>%
    mutate(key="Mean\nof all\nkeys") %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n())
)

# get the max number of samples for any key
col_scale_end <- max((per_key_valences %>% filter(key != "Mean\nof all\nkeys"))$count)

# TODO: add error bar or smth or communicate number of tracks per key/mode
# TODO: fix legend
bar_plot <- per_key_valences %>%
  ggplot(aes(key, avg_sentiment, fill=mode, col=count)) +
  geom_col(position=position_dodge(width=0.75)) +
  geom_vline(xintercept=12.5, linetype="dotted", col="black") +
  labs(title="Mean lyrical valence per key, for either, the major and the minor mode", x="Key", y="Mean lyrical valence") +
  scale_fill_manual(values=c("Either"="gray", "Major"="lightblue", "Minor"="navy")) +
  scale_color_viridis_c(option="rocket", limits=c(0, col_scale_end)) +
  custom_theme

ggplotly(bar_plot)
```

***

Though finding specific melodies is a difficult task to automize, we could look at the key in which the melody is played.

### Harmony

```{r generate chord templates, include=FALSE}
#! generate chord templates

shift_template <- function(temp, n) {
  if (n == 0) temp
  else c(tail(temp, n), head(temp, -n))
}

mode_templates <- list(
  # TODO: where are these from?
  maj=c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88),
  min=c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)
)

key_templates <- list()
for (key_idx in seq_along(ugly_keys)) {
  for (mode in names(mode_templates)) {
    chord_name <- sprintf("%s:%s", ugly_keys[key_idx], mode)
    template <- shift_template(mode_templates[[mode]], key_idx-1)
    
    key_templates[[chord_name]] <- template
  }
}

key_templates <- tibble(name=names(key_templates), template=key_templates)
```

```{r harmony, message=FALSE}
# TODO: use my god is the sun somewhere
# TODO: use some nice facet wrap somewhere

# TODO: pick any fun song, no good reason required
get_key_match_plot <- function(uri, title) {
  key_analysis <- get_tidy_audio_analysis(uri) %>%
    compmus_align(sections, segments) %>%
      select(sections) %>%
      unnest(sections) %>%
      mutate(pitches=map(
          segments, compmus_summarize, pitches,
          method="rms", norm="euclidean"
      ))
  
  key_matching <- key_analysis %>%
    compmus_match_pitch_template(
      key_templates,
      method="euclidean",
      norm="euclidean"
    ) %>%
    # invert colors
    mutate(d = 1 - d)
  
  key_matching %>%
    ggplot(aes(start + duration/2, name, width=duration, fill=d)) +
    geom_tile() +
    scale_fill_viridis_c(option="mako", guide="none") +
    labs(x="Time (seconds)", y="", title=title) +
    theme_minimal() +
    custom_theme
}

plot_grid(
  get_key_match_plot("0gTRROuntlrPQ64W3J2Etv", "Key matching for\nElectioneering")
,
  get_key_match_plot("5dZ8PeKKZJLIQAWNTdp8WX", "Key matching for\nRevolution 9")
)
```

***

The troubles with key matching.

### Instrumentation

```{r}
# TODO: have pretty keynames everywhere
# TODO: timbre self-similarity

# TODO: timbre options are: self-similarity, timbre components

```

### Rhythm

```{r word cloud, warning=FALSE}

# NOTE: for an annoying reason one 1 word cloud can be displayed

# TODO: random gradient in color

# TODO: faceted word cloud, 1 plot for low tempo, 1 for high tempo, also include some lyrical valency analysis

GROUP_COUNT <- 80
MIN_FREQ <- 0.0015

median_tempo <- median(corpus$tempo)

# load all words
lyrics_db <- jsonlite::fromJSON(LYRICS_FILE)[c("track", "lyrics")]
rownames(lyrics_db) <- lyrics_db$track

# lyrics of all the slow songs
slow_lyrics <- c()
# lyrics of all the fast songs
fast_lyrics <- c()

# gather lyrics
for (i in 1:nrow(corpus)) {
    row <- corpus[i,]
    lyrics <- lyrics_db[row$track,]$lyrics
    
    if (row$tempo < median_tempo) {
      slow_lyrics <- c(slow_lyrics, lyrics)
    } else {
      fast_lyrics <- c(fast_lyrics, lyrics)
    }
}

clean_text <- function(txt) {
  all_lyrics <- Corpus(VectorSource(txt))
  
  # clean text
  all_lyrics <- all_lyrics %>%
    tm_map(removeNumbers) %>%
    tm_map(removePunctuation) %>%
    tm_map(stripWhitespace) %>%
    tm_map(content_transformer(tolower)) %>%
    tm_map(removeWords, stopwords("english"))
  
  matrix <- as.matrix(TermDocumentMatrix(all_lyrics))
  words <- sort(rowSums(matrix), decreasing=TRUE)
  # get relative frequencies
  word_freqs <- data.frame(word=names(words), freq=words / sum(words))
    return(word_freqs)
}

# clean lyrics
slow_word_freqs <- clean_text(paste(slow_lyrics, collapse=" "))
fast_word_freqs <- clean_text(paste(fast_lyrics, collapse=" "))

# TODO: have top 50 of either category in there
# TODO: mention relative frequency somewhere
normalize <- function(x) (x - min(x)) / (max(x) - min(x))

# compute differences in frequencies
all_words <- merge(slow_word_freqs, fast_word_freqs, by="word", suffixes=c("_slow", "_fast"))
all_words$freq_slow <- normalize(pmax(all_words$freq_slow - all_words$freq_fast, 0))
all_words$freq_fast <- normalize(pmax(all_words$freq_fast - all_words$freq_slow, 0))

word_freqs <- rbind(
  all_words[c("word", "freq_slow")] %>%
    rename(freq=freq_slow) %>%
    arrange(desc(freq)) %>%
    head(n=GROUP_COUNT) %>%
    mutate(col = "red"),

  all_words[c("word", "freq_fast")] %>%
    rename(freq=freq_fast) %>%
    arrange(desc(freq)) %>%
    head(n=GROUP_COUNT) %>%
    mutate(col = "skyblue")
) %>% filter(freq >= MIN_FREQ)

word_freqs %>%
  wordcloud2(
    fontFamily=portfolio_font, shuffle=FALSE,
    color=word_freqs$col, size=1.0, widgetsize=c(750, 750)
  )

```

***

*Hypothesis: higher tempo songs tend to be more aggressive and slower songs more sensual.*

Let's put this one to the test. For this hypothesis we'll denote songs that have a lower BPM than the median (< `r median_tempo`BPM) as slow songs, and the rest songs as fast songs (≥ `r median_tempo`BPM).

So far we've explored only the lyrical valency property, but not the lyrics themselves. We might gain some
new insights if we look at the lyrics directly, so let's try it. One of the most useful tools for visualizing
patterns in textual data is a so called `word cloud`, which you can see to the side. 
The words in <span style="color:skyblue">blue</span> refer to words that occur very frequently in
fast songs relative to slow songs, and vice versa for the <span style="color:red">red</span> words.

Immediately we can see instances that prove the hypothesis. Slow song words include sensual words such as *number* (as in, someones phone number), *kiss*, *boy* and *hot*. These are words we would expect to encounter in a love song. Though what stands out is that 
*love* is included in the fast songs. There are also some odd ones out like *bones*.
As for the fast tracks we also find what one would expect, e.g. aggressive words like *kill*, *gun* and *ill*. Also, very noticeably, we find numerous verbs and filler words. This makes sense in a track where the singer (or rapper) has to keep up the pace in a high BPM track, and it's easiest for the listener and artist to reuse many of the common verbs and filler words to keep the information stream somewhat limited.

Most of the data in this plot seems to **confirm** the hypothesis (though there are exceptions, like *love* among the fast tracks).


### Conclusion


