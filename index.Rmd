---
title: "Portfolio"
author: "Morris de Haan"
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    storyboard: true
    
    css: style.css
    theme:
      version: 4
      bootswatch: cerulean
---

```{r setup, include=FALSE}
library(flexdashboard)
library(tidyverse)
library(spotifyr)
library(ggplot2)
library(compmus)
library(jsonlite)
library(dplyr)
library(plotly)
library(cowplot)
library(showtext)
library(tm)
library(wordcloud2)
library(patchwork) # TODO: necessary?
library(caret)
library(recipes)
library(tidymodels)
library(doParallel)
library(vip)

# load environment variables
readRenviron(".Renviron")

portfolio_font <- "Times New Roman"
custom_theme <- theme(text=element_text(family=portfolio_font))

RUN_XGBOOST_TUNING = TRUE # TODO: remove
```

```{r load corpus, include=FALSE}
#! fetch data

corpus_raw <- get_playlist_audio_features("", "1H9BY5uJqk2CWtPo4Ogi2w")
```

```{r preprocess corpus, include=FALSE}
#! preprocess data

corpus <- corpus_raw %>% select(
  acousticness, danceability, energy, instrumentalness, loudness, mode, tempo, valence, key,
  popularity=track.popularity, artists=track.artists, track=track.name
)

# key index --> key name
pretty_keys <- c("C", "C♯|D♭", "D", "D♯|E♭", "E", "F", "F♯|G♭", "G", "G♯|A♭",  "A", "A♯|B♭", "B")
ugly_keys <- c("C", "C#|Db", "D", "D#|Eb", "E", "F", "F#|Gb", "G", "G#|Ab", "A", "A#|Bb", "B")
corpus$key <- unlist(map(corpus$key, function(idx) if (idx == -1) "Unknown" else pretty_keys[idx+1]))

# mode index --> mode name
corpus$mode <- unlist(map(corpus$mode, function(idx) if (idx == 1) "Major" else "Minor"))

# concatenate artist names into single string
corpus$artists <- unlist(map(corpus$artists, function(r) paste(r$name, collapse=", ")))

# TODO: tempo to perceived tempo?
```

```{r fetch lyrics, include=FALSE}
#! load lyrics, delete entries from corpus whose lyrics cannot be fetched

LYRICS_DIR <- "./res"
LYRICS_FILE <- "./res/lyrics.json"
LYRICS_APIKEY <- Sys.getenv("MUSIXMATCH_APIKEY")
LYRICS_URL <- sprintf(paste(
  "https://api.musixmatch.com/ws/1.1/matcher.lyrics.get?",
  "q_track=%s&q_artist=%s&apikey=%s", sep=""),
  "%s", "%s", LYRICS_APIKEY
)

# fetches the lyrics of a track from some artists from Musixmatch
get_lyrics <- function(track, artists) {
  # there may be no spaces in the URL
  track <- gsub(" ", "%20", track)
  artists <- gsub(" ", "%20", artists)
  
  data <- jsonlite::fromJSON(sprintf(LYRICS_URL, track, artists))
  lyrics <- data$message$body$lyrics$lyrics_body
  # remove warning at the end
  lyrics <- gsub(
    "\n...\n\n\\*{7} This Lyrics is NOT for Commercial use \\*{7}.*",
    "", lyrics
  )
  return(lyrics)
}

# load stored lyrics
if (!file.exists(LYRICS_FILE)) {
  lyrics_db <- data.frame(
    track=character(), artists=character(),
    album=character(), lyrics=character()
  )
  
  dir.create(LYRICS_DIR)
} else {
  # fetch all previously cached lyrics
  lyrics_db <- jsonlite::fromJSON(LYRICS_FILE)
}

for (i in 1:nrow(corpus)) {
  row <- corpus[i,]
  
  # check if lyrics are already loaded
  if (!(row$track %in% lyrics_db$track)) {
    # fetch lyrics
    lyrics <- get_lyrics(row$track, row$artists)
    if (length(lyrics) == 0)
      lyrics <- NA
    
    # store lyrics
    lyrics_db <- lyrics_db %>% add_row(
      track=row$track, artists=row$artists,
      lyrics=lyrics
    )
  }
}

# cache lyrics
write(jsonlite::toJSON(lyrics_db, pretty=TRUE), LYRICS_FILE)
```

```{r compute sentiment, include=FALSE}
#! add lyrical sentiment values to corpus, delete tracks from corpus
#!  that have no available lyrics

# compute sentiments
system("python3 lyrics.py")

lyrics_db <- jsonlite::fromJSON(LYRICS_FILE)[c("track", "sentiment")]

corpus <- merge(corpus, lyrics_db, by="track") %>%
  rename(lyrical_sentiment=sentiment) %>%
  drop_na(lyrical_sentiment)
```

### Introduction

How does music relate to the lyrics? It is tempting to think that a song tries to convey some feeling or emotion, and that both the music and lyrics are there to support this message. Let me give you an example. We might expect a song with a slow beat and laid back guitar to talk about laid back topics, maybe a trip to the beach. At the other end of the spectrum, heavy metal would likely concern itself with darker, heavier subjects. However, are these suspicions even true? Let’s put some numbers to the hypothesis that there in fact is a relationship between music and lyrics. In the next sections I’ll take you through a journey where we approach this topic with a statistical mindset, harnessing all the powers that modern technology has to offer along the way.

We'll start out with picking a large body of music and for each track in there, we are going to collect and store the lyrics. It would be way too cumbersome to scrape all the lyrics from the internet myself, but fortunately the [`Musixmatch`](https://www.musixmatch.com/) API
allows querying lyrics from code in a single API call. For an unpaid account only 30% of the lyrics for a queried track is returned, but that will do for our intents and purposes. I assign every set of lyrics a sentimental, or valency, score automatically using the 
[`NLTK`](https://www.nltk.org/) package, which offers natural language processing functionalities. A low score indicates a *sad* feeling, whereas a high score a *happy* feeling. When the lyrics have a numerical score we can start to answer our question: how does music relate to lyrics?

The research question is still a bit broad. We settled on how to analyze lyrics, but not yet on which aspects on music we'll focus.
We are going to keep the research broad, and explore how the lyrics relate to the four main elements of music, that is *melody*, *harmony*, *instrumentation* and *rhythm*. To access and preprocess the music properties the [`Spotify`](https://developer.spotify.com/documentation/web-api) API is used. For each element we will either confirm or refute
any hypotheses that intuitively make a lot of sense, but are not (yet) backed up by data.

Let us dive into it!

### Corpus

The first order of business is choosing the corpus of music. We have chosen a broad research question and the corpus should
reflect this. It must draw inspiration from various genres and contain a large number of songs, only then can we
justify general conclusions. Because the heavy lifting in terms of fetching the data we need is done by the `Musixmatch` and `Spotify` APIs,
this is most certainly possible.

The exhaustive list of albums that are included in this research:

<span style="color:blue">
Elephant, Madvillainy, ..Like Clockwork, Street Worms, Midnights,
HEROES & VILLAINS, St. Elsewhere, The White Album, Plastic Beach,
Demon Days, Thriller, In the Aeroplane Over the Sea, Hawaii: Part ||,
WHEN WE ALL FALL ASLEEP, WHERE DO WE GO?, Dua Lipa, The Money Store, OFFLINE!,
OK Computer and Rumours
</span>

This totals over **280** tracks and **16** hours of listening time.

***

**Playlist**

<iframe src="https://open.spotify.com/embed/playlist/1H9BY5uJqk2CWtPo4Ogi2w?utm_source=generator" width="100%" height="380" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>

### Discovery

```{r discovery}
# TODO: where did the popularity legend go??
ggplotly(
  ggplot(corpus, aes(valence, lyrical_sentiment, col=loudness, size=popularity, text=paste(track, "by", artists))) +
  geom_point() +
  geom_smooth(inherit.aes=FALSE, aes(valence, lyrical_sentiment)) +
  geom_rug(linewidth=0.2) +
  labs(title="Musical vs. Lyrical Valence", x="Musical valence", y="Lyrical Valence", col="Loudness (Decibels)", size="Popularity") +
  custom_theme
)
```

***

The `Spotify` API offers a plethora of functionalities that range from very high to very low level. Here we will use some the the high level analyses
like valence and energy to learn about the corpus.

When we plot energy, musical and lyrical valence values against each other we find something enormously interesting.
Clearly, even though energy and valence do not seem related, musical and lyrical valence appear highly correlated.

### Melody

```{r melody}
get_audio_analysis <- function(uri) {
  get_tidy_audio_analysis(uri) %>%
    select(segments) %>%
    unnest(segments) %>%
    select(start, duration, pitches)
}

get_chromogram <- function(analysis, title) {
  analysis %>%
    mutate(pitches=map(pitches, compmus_normalize, "euclidean")) %>%
    compmus_gather_chroma() %>%
    ggplot(aes(start + duration*0.5, pitch_class, width=duration, fill=value)) +
    geom_tile() +
    labs(title=title, x="Time (seconds)", y=NULL, fill="Magnitude") +
    # TODO: part of custom theme?
    scale_fill_viridis_c(option="mako", guide="none") +
    theme_minimal() +
    custom_theme
}

# Ball and Biscuit by the white stripes
happy_analysis <- get_audio_analysis("0O2SYh5AZ0y8MAPOVC4Mxz")
# The Illest Villains by Madvillain
sad_analysis <- get_audio_analysis("2Jn0wHQ2lEif2gLRsyfaf2")

happy_entry <- (corpus %>% filter(track == "Ball and Biscuit"))
sad_entry <- (corpus %>% filter(track == "The Illest Villains"))

# TODO: fix background
plot_grid(
  get_chromogram(happy_analysis,
    sprintf("%s chromogram (lyrical valency = %s)", happy_entry$track,
      format(happy_entry$lyrical_sentiment, digits=2)
  )),
  get_chromogram(sad_analysis,
    sprintf("%s chromogram (lyrical valency = %s)", sad_entry$track,
      format(sad_entry$lyrical_sentiment, digits=2)
  )),
  nrow=2
)
```

***

*Research: can we identify melodies from audio data?*

Intuitively, it seems that melody encodes a lot of the valency information of a song. The melody is usually the most
memorable part and often indicative of the feel of a song. So it makes sense to look at the melody of two tracks, one with low and one
with high lyrical valence, and investigate how melody correlates with lyrical valence. A sensible visualization tool to use is a chromogram. This captures for each moment the notes that are played, as analyzed using the fourier transform. Let's try this and see if any melody lines become apparent.

Unfortunately, looking at the chromograms, no discernible melody is recognizable. The only thing that sticks out is the droning 'E' in Ball and Biscuit, but this could hardly be called a melody. It appears we need a different tool.

TODO: explain what melody the human ear hears, and that it's not detected

### Melody/Harmony

```{r per key lyrical valence, message=FALSE}
# TODO: optimize
per_key_valences <- rbind(
  # add average per key
  corpus %>%
    mutate(mode="Either") %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n()),
  corpus %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n()),
  # add average for all keys
  corpus %>%
    mutate(key="Mean\nof all\nkeys", mode="Either") %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n()),
  corpus %>%
    mutate(key="Mean\nof all\nkeys") %>%
    group_by(key, mode) %>%
    summarize(avg_sentiment = mean(lyrical_sentiment), count = n())
)

# get the max number of samples for any key
col_scale_end <- max((per_key_valences %>% filter(key != "Mean\nof all\nkeys"))$count)

# TODO: add error bar or smth or communicate number of tracks per key/mode
# TODO: fix legend
bar_plot <- per_key_valences %>%
  ggplot(aes(key, avg_sentiment, fill=mode, col=count)) +
  geom_col(position=position_dodge(width=0.75)) +
  geom_vline(xintercept=12.5, linetype="dotted", col="black") +
  labs(title="Mean lyrical valence per key, for either, the major and the minor mode", x="Key", y="Mean lyrical valence") +
  scale_fill_manual(values=c("Either"="gray", "Major"="lightblue", "Minor"="navy")) +
  scale_color_viridis_c(option="rocket", limits=c(0, col_scale_end)) +
  custom_theme

ggplotly(bar_plot)
```

***

*Research: what is the saddest key?*

Apparently it's difficult to find melodies when faced with a chromogram. Instead of identifying specific melody lines, we could
focus on the key in which the melody is played. Luckily `Spotify` gives us the key and mode of every track in our corpus, so
we don't have to compute this ourselves. When we plot the lyrical valency for each key, where the band around the bars represents
the number of tracks that have that specific key, we get the bar plot to the side. What meets the eye, is a huge spike
at the D sharp (or E flat) key. What could this mean? Unfortunately not a lot, because upon closer inspection it appears that
songs in that key are for heavily underrepresented in the corpus. There does seem to be quite a bit of variation among keys,
especially the keys in B, which appear to affect lyrics in a negative way. This points to the fact that there in fact is such a thing, like "the saddest key" (which would be B major).

Although this could be coincidental and the effect may be cancelled out if the corpus were much larger. Somethings that favor this conclusion
are the average lyrical valencies, which converge to a lyrical valency of `~0.13`. There is no significant distinction between the average major and minor mode, even though we're always told that minor keys are "sad" and major keys are "happy". These results deny what our music teachers have been telling us for centuries!

### Harmony detection limitations

```{r generate chord templates, include=FALSE}
#! generate chord templates

shift_template <- function(temp, n) {
  if (n == 0) temp
  else c(tail(temp, n), head(temp, -n))
}

mode_templates <- list(
  # TODO: where are these from?
  maj=c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88),
  min=c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)
)

key_templates <- list()
for (key_idx in seq_along(ugly_keys)) {
  for (mode in names(mode_templates)) {
    chord_name <- sprintf("%s:%s", ugly_keys[key_idx], mode)
    template <- shift_template(mode_templates[[mode]], key_idx-1)
    
    key_templates[[chord_name]] <- template
  }
}

key_templates <- tibble(name=names(key_templates), template=key_templates)
```

```{r harmony, message=FALSE}
# TODO: use my god is the sun somewhere
# TODO: use some nice facet wrap somewhere

# TODO: pick any fun song, no good reason required
get_key_match_plot <- function(uri, title) {
  key_analysis <- get_tidy_audio_analysis(uri) %>%
    compmus_align(sections, segments) %>%
      select(sections) %>%
      unnest(sections) %>%
      mutate(pitches=map(
          segments, compmus_summarize, pitches,
          method="rms", norm="euclidean"
      ))
  
  key_matching <- key_analysis %>%
    compmus_match_pitch_template(
      key_templates,
      method="euclidean",
      norm="euclidean"
    ) %>%
    # invert colors
    mutate(d = 1 - d)
  
  key_matching %>%
    ggplot(aes(start + duration/2, name, width=duration, fill=d)) +
    geom_tile() +
    scale_fill_viridis_c(option="mako", guide="none") +
    labs(x="Time (seconds)", y="", title=title) +
    theme_minimal() +
    custom_theme
}

plot_grid(
  get_key_match_plot("0gTRROuntlrPQ64W3J2Etv", "Keygram for\nElectioneering (Radiohead)")
,
  get_key_match_plot("0ubyD2iLcA6W90tMaKyXs2", "Keygram for\nUNTITLED (JPEGMAFIA)")
)
```

***

I should address some issues with automatic key matching that explain why we should take the idea that B major is the
saddest key with an even larger grain of salt. Key matching might work for a lot of tracks, but there are many cases where it fails too.
Where key matching fails most spectacularly, is for highly percussive tracks, which is usually the case for hip hop. This is due to
the inharmonic nature of most percussive instruments.
Take for instance *UNTITLED* by *JPEGMAFIA*. Upon listening, the energetic hi hats and fast drum kicks stand out.
This is manifested in the corresponding keygram, where for each section every key on the y-axis is matched.
The brighter the tile, the more strongly the key matched. We'd expect a straight line, that changes height after a modulation. But in the *UNTITLED* track there is no such pattern to be found.

Another issue is brought forward by a limitation by the `Spotify` API, that is, only two unique modes can be distinguished by
the API (the major and minor mode). This is problematic, because many artists apply many different modes to achieve a variety
of effects that cannot be achieved by just minor or major keys. The song *Electioneering* by *Radiohead* is in D-dorian,
which is the minor key with a raised sixth. The result is that the key lies somewhere in between D-minor and D-major, which is reflected in the keygram.

Though we could match the keys ourselves for every track in the corpus, another issue would present. To match every possible mode,
the search space would become too big and our results too cluttered to identify a specific key, as multiple keys would always
match somewhat.

### Instrumentation

```{r}
# TODO: have pretty keynames everywhere

# TODO: show timbre component plot, along with plot that takes in entire corpus

```

### Rhythm

```{r word cloud, warning=FALSE}

# NOTE: for an annoying reason one 1 word cloud can be displayed

# TODO: random gradient in color

# TODO: faceted word cloud, 1 plot for low tempo, 1 for high tempo, also include some lyrical valency analysis

GROUP_COUNT <- 80
MIN_FREQ <- 0.0015

median_tempo <- median(corpus$tempo)

# load all words
lyrics_db <- jsonlite::fromJSON(LYRICS_FILE)[c("track", "lyrics")]
rownames(lyrics_db) <- lyrics_db$track

# lyrics of all the slow songs
slow_lyrics <- c()
# lyrics of all the fast songs
fast_lyrics <- c()

# gather lyrics
for (i in 1:nrow(corpus)) {
    row <- corpus[i,]
    lyrics <- lyrics_db[row$track,]$lyrics
    
    if (row$tempo < median_tempo) {
      slow_lyrics <- c(slow_lyrics, lyrics)
    } else {
      fast_lyrics <- c(fast_lyrics, lyrics)
    }
}

clean_text <- function(txt) {
  all_lyrics <- Corpus(VectorSource(txt))
  
  # clean text
  all_lyrics <- all_lyrics %>%
    tm_map(removeNumbers) %>%
    tm_map(removePunctuation) %>%
    tm_map(stripWhitespace) %>%
    tm_map(content_transformer(tolower)) %>%
    tm_map(removeWords, stopwords("english"))
  
  matrix <- as.matrix(TermDocumentMatrix(all_lyrics))
  words <- sort(rowSums(matrix), decreasing=TRUE)
  # get relative frequencies
  word_freqs <- data.frame(word=names(words), freq=words / sum(words))
    return(word_freqs)
}

# clean lyrics
slow_word_freqs <- clean_text(paste(slow_lyrics, collapse=" "))
fast_word_freqs <- clean_text(paste(fast_lyrics, collapse=" "))

# TODO: have top 50 of either category in there
# TODO: mention relative frequency somewhere
normalize <- function(x) (x - min(x)) / (max(x) - min(x))

# compute differences in frequencies
all_words <- merge(slow_word_freqs, fast_word_freqs, by="word", suffixes=c("_slow", "_fast"))
all_words$freq_slow <- normalize(pmax(all_words$freq_slow - all_words$freq_fast, 0))
all_words$freq_fast <- normalize(pmax(all_words$freq_fast - all_words$freq_slow, 0))

word_freqs <- rbind(
  all_words[c("word", "freq_slow")] %>%
    rename(freq=freq_slow) %>%
    arrange(desc(freq)) %>%
    head(n=GROUP_COUNT) %>%
    mutate(col = "red"),

  all_words[c("word", "freq_fast")] %>%
    rename(freq=freq_fast) %>%
    arrange(desc(freq)) %>%
    head(n=GROUP_COUNT) %>%
    mutate(col = "skyblue")
) %>% filter(freq >= MIN_FREQ)

word_freqs %>%
  wordcloud2(
    fontFamily=portfolio_font, shuffle=FALSE,
    color=word_freqs$col, size=1.0, widgetsize=c(750, 750)
  )

```

***

*Hypothesis: higher tempo songs tend to be more aggressive and slower songs more sensual.*

Let's put this one to the test. For this hypothesis we'll denote songs that have a lower BPM than the median (< `r median_tempo`BPM) as slow songs, and the remainder as fast songs (≥ `r median_tempo`BPM).

So far we've explored only the lyrical valency property, but not the lyrics themselves. We might gain some
new insights if we look at the lyrics directly, so let's try it. One of the most useful tools for visualizing
patterns in textual data is a so called `word cloud`, which you can see to the side. 
The words in <span style="color:skyblue">blue</span> refer to words that occur very frequently in
fast songs relative to slow songs, and vice versa for the <span style="color:red">red</span> words.

Immediately we can see instances that prove the hypothesis. Slow song words include sensual words such as *number* (as in, someones phone number), *kiss*, *boy* and *hot*. These are words we would expect to encounter in a love song. Though what stands out is that 
*love* is included in the fast songs. There are also some odd ones out like *bones*.
As for the fast tracks we also find what one would expect, e.g. aggressive words like *kill*, *gun* and *ill*. Also, very noticeably, we find numerous verbs and filler words. This makes sense in a track where the singer (or rapper) has to keep up the pace in a high BPM track, and it's easiest for the listener and artist to reuse many of the common verbs and filler words to keep the information stream somewhat limited.

Most of the data in this plot seems to **confirm** the hypothesis (though there are exceptions, like *love* among the fast tracks).

### AI: hyperparameter tuning

```{r tune xgboost}
#! build dataset

# NOTE: can take a long time to run, set to TRUE if it needs to be computed
if (RUN_XGBOOST_TUNING) {
  # make process deterministic
  set.seed(421)

  data <- corpus[c("danceability", "energy", "key", "loudness", "mode",
                   "tempo", "valence", "lyrical_sentiment"
  )]
  # columns to numeric, centering and scaling is not necessary for tree based models
  data$mode <- as.numeric(factor(data$mode))
  data$key <- as.numeric(factor(data$key))
  
  # split into train and test set
  data_split <- initial_split(data, strata=lyrical_sentiment)
  data_train <- training(data_split)
  data_test <- testing(data_split)
  # cross validation
  train_data_cv <- vfold_cv(data_train, strata=lyrical_sentiment, v=2)
  
  # build model
  xgb_specs <- boost_tree(
    mode="regression", engine="xgboost",
    trees=tune(), tree_depth=tune(),
    min_n=tune(), loss_reduction=tune(),
    sample_size=tune(), mtry=tune(),
    learn_rate=tune()
  )
  
  xgb_model <- workflow() %>%
    add_formula(lyrical_sentiment ~ .) %>%
    add_model(xgb_specs)
  
  # configure grid search to find optimal parameters
  xgb_grid <- grid_latin_hypercube(
    trees(), tree_depth(), min_n(), loss_reduction(),
    sample_size=sample_prop(),
    finalize(mtry(), data_train),
    learn_rate(),
    size=30
  )
  
  # find optimal parameters
  doParallel::registerDoParallel()
  
  xgb_params <- tune_grid(
    xgb_model,
    resamples=train_data_cv,
    grid=xgb_grid,
    control=control_grid(save_pred=TRUE) # TODO: necessary?
  )
  
  best_params <- select_best(xgb_params, metric="rmse")
  best_params_rmse <- show_best(xgb_params, metric="rmse")[1,]$mean
}
```

```{r plot xgboost params}
ggplotly(xgb_params %>%
  collect_metrics() %>%
  filter(.metric == "rmse") %>%
  select(mtry:sample_size, mean) %>%
  pivot_longer(mtry:sample_size, values_to="value", names_to="parameter") %>%
  ggplot(aes(value, mean, color=parameter)) +
  geom_point(show.legend=FALSE) +
  facet_wrap(~parameter, scales="free_x") +
  labs(title="XGboost parameter space", x="Parameter value", y="Mean RMSE (root mean square error)") +
  custom_theme
)

# TODO: display best params?
```

***

*Research: are there some hidden relationships that have yet to be found?*

So far we have plotted numerous relationships between different variables and debunked or confirmed a number of hypotheses.
Though the reason I picked those visualizations is because there seemed to be potential for an interesting correlation, there
is still a chance there exist some totally unexpected patterns. Because these may escape a mere human like me, maybe the right
machine learning tool can pick them up. So that's what we'll be trying.

The technique we'll use is one of *the* most successful machine learning algorithms of the modern day, called extreme gradient boosting (XGBoosting). In essence, it's an ensemble of many small decision trees that boost each other to achieve superior results. To uncover secret relationships we will train the network, using regression, to predict the lyrical valency of a song based on a whole array of inputs that the `Spotify` API delivers (like mode, tempo, musical valence, etc.). Before we dive in and use it, some preparations need to be taken care of. First, the corpus is split into a train set (to train the model) and test set (to evaluate the model). Next up, for XGBoosting to work we need to list a number of hyperparameters. The next step then is to tune these hyperparameters, by training the model for many different combinations of hyperparameters and evaluating each using cross validation. In the plot you can see how well each parameter value works: the lower RMSE, the better. Now that we know the optimal combination we can finally properly train and evaluate the model.

### AI: results

```{r plot xgboost importancies}
final_xgb_model <- finalize_workflow(xgb_model, best_params)

# train model
ggplotly(final_xgb_model %>%
  fit(data=data_train) %>%
  extract_fit_parsnip() %>%
  vip(geom = "point") +
  labs(title="Feature importances", x="Importance", y="Feature")
)
```

```{r evaluate xgboost model}
xgb_rmse <- (collect_metrics(last_fit(final_xgb_model, data_split)) %>% filter(.metric == "rmse"))$.estimate

# compute RMSE for a random model
guesses <- runif(nrow(data_test))
random_rmse <- sqrt(mean((data_test$lyrical_sentiment - guesses)^2))
```


***

After training the model, we end up with a RMSE (root mean square error) of ``r xgb_rmse``. This means that the model, on average, is that
far off from the correct answer. As a reminder: the lyrical valency ranges from `-1` to `1`. It could well be that this still sounds
quite abstract. As a comparison I also evaluated a model that always makes a random guess. That model performs with a RMSE
of ``r random_rmse``, which is significantly worse. Therefore, the XGBoosting model must have found some pattern. That
makes it worth to look at whatever it found. One valuable piece of information that we can extract from the XGBoosting model, is the
set of feature importances it learned. They tell us how important each input parameter is deemed for predicting the lyrical valency, which you can see in the plot.

Many of the findings we found ourselves already. We already discovered that the mode of the key does not matter.
We found that musical valence and tempo correlate with lyrical valency. More interesting is what we did not find.
Apparently, according to the model, is energy the most predictive factor of the lyrical valency, even more so than musical valency.
This makes sense intuitively. High energy songs might be more likely to have more energetic lyrics. The model also judges
loudness and danceability as somewhat important features. A reason could be that the genre of a track defines in which range those features, including energy, belong, and that the genre also defines what the lyrics are generally about.

### Conclusion

To be concluded.

